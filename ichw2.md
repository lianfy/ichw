1. 他为了证明没有算法来判定任意丢番图方程是否有整数解

   假设有某种算法，一个一个整数进行验证，若有解，则机器停止；若无解，则机器一直运转下去

   图灵从理论上证明这种算法是不存在的

   证明：假设存在一个“上帝”算法**f**，若某程序可以停机返回**true**，若不能停机返回**false**

   我们构造一个程序**g**，如果**f**的返回值是**true**,让机器一直运转，并返回**false**

   ​                                     如果**f**的返回值是**false**,则返回**true**

   那么当把**g**程序输入**g**程序时，如果**g**能**停机**，机器将**一直转下去**

   ​                                                  如果**g不能停机**，机器将**停机**，矛盾

   所以不存在这样的“上帝”算法**f**

   数学原理：哥德尔不完备定理

   假设存在一个"上帝"图灵机N，对于会停机的输入输出0，对于不会停机的输入输出1

   所有图灵机构成一个集合（M~1~ ,M~2~,...,M~N~)

   构造一个新的图灵机M~N+1~,使得它对于输入1的输出与M~1~不一样，对于输入2的输出与M~2~不一样...

   那么M~N+1~（i）的输出就和M~i~（i）相反

   所以N不能判断M~N+1~（i）是否能停机



2. 对于正数，二进制补码就是它本身

   对于码长为N的负数-n，二进制补码是2<sup>n</sup>-n，也即补码为反码加一

   负数的反码即先忽略符号转化为二进制，再每位取反

   因此，补码中只有一个零

   而原码中有两个0（00000000、10000000）

   反码中也有两个0（00000000、11111111）

   补码的另一个好处是加减运算方便

   先把减法看成加上另一个数的相反数

   两数相加时把所有位数相加，舍弃溢出的部分

   例如：码长4位，求4-3

   4的补码0100，-3的补码1101，加起来为0001，所以结果是1

   原理：设正数为**x**，负数为-**y**

   ​            若**x**<**y**,结果为2^N^-(**y-x**),即-(**y-x**）

   ​            若**x**=**y**,结果为2^N^,即**0**

   ​            若**x**>**y**,结果为**x-y**



3. 

1. | **Sigh** | **Exp**  | **Frac    | **Value                             |
   | -------- | -------- | --------- | ----------------------------------- |
   | *        | 000 0000 | 0000 0000 | ±0.0                                |
   | 0        | 011 1111 | 0000 0000 | 1.0                                 |
   | 1        | 011 1111 | 0000 0000 | -1.0                                |
   | *        | 000 0000 | 1111 1111 | ±(1-2<sup>-8</sup>)*2<sup>-62</sup> |
   | *        | 000 0000 | 0000 0001 | ±2<sup>-8</sup>*2<sup>-62</sup>     |
   | *        | 000 0001 | 0000 0000 | ±2<sup>-62</sup>                    |
   | *        | 111 1110 | 1111 1111 | ±(2-2<sup>-8</sup>)*2<sup>63</sup>  |
   | *        | 111 1111 | 0000 0000 | ±∞                                  |
   | *        | 111 1111 | non zero  | NaN                                 |
